首先根据输入数据，我这里演示数据为 {9,7,3,4}，然后生成矩阵：
```
{
  {1,0,0,0},
  {0,1,0,0},
  {0,0,1,0},
  {0,0,0,1},
  {1,1,1,1},
  {1,2,4,8}
}
```
然后使用这个矩阵与输入数据做矩阵相乘：
```
{
  {1,0,0,0},
  {0,1,0,0},
  {0,0,1,0},
  {0,0,0,1},
  {1,1,1,1},
  {1,2,4,8}
}

*

{9,7,3,4}

=

{9,7,3,4,23,67}
```
经过上面计算，得到：`{9,7,3,4,23,67}`

其中末尾 `23, 67` 即是我们的冗余数据, 可用于恢复输入数据中任意丢失的2份数据。

这里假设 `9, 3` 丢失: `{x,7,x,4,23,67}`，先根据之前的矩阵，去掉丢失所对应的行：
```
{
# {1,0,0,0},
  {0,1,0,0},
# {0,0,1,0},
  {0,0,0,1},
  {1,1,1,1},
  {1,2,4,8}
}

即：

{
  {0,1,0,0},
  {0,0,0,1},
  {1,1,1,1},
  {1,2,4,8}
}
```
然后对这个矩阵进行反转，得到逆矩阵：
```
{
  {-2/3,4/3,4/3,-1/3},
  {1,0,0,0},
  {-1/3,-7/3,-1/3,1/3},
  {0,1,0,0}
}
```
使用这个逆矩阵与接收到的数据相乘：
```
{
  {-2/3,4/3,4/3,-1/3},
  {1,0,0,0},
  {-1/3,-7/3,-1/3,1/3},
  {0,1,0,0}
}

*

{7,4,23,67}
```
得到完整的数据还原：
```
{9,7,3,4}
```

上面过程，这里我使用 python 来简单模拟一下整个过程：

``` python
import numpy as np
#测试数据
data=np.array([9,7,3,4])
#创立矩阵：
vandermonde=np.array([[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1],[1,1,1,1],[1,2,4,8]])
#计算parity, parity=[9,7,3,4,23,67]
parity=np.dot(vandermonde, data) 

#假设9，3丢失，删除矩阵中对应行，然后建立逆矩阵。
lost=np.array([7,4,23,67])
vandermonde_inv=np.array([[0,1,0,0],[0,0,0,1],[1,1,1,1],[1,2,4,8]])
vandermonde_inv=np.linalg.inv(vandermonde_inv)

#恢复数据result=[9,7,3,4]
result=np.dot(vandermonde_inv,lost)
```
